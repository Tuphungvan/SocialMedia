================================================================================
HÆ¯á»šNG DáºªN KIáº¾N THá»¨C NÃ‚NG CAO - SOCIAL MEDIA BACKEND
Giáº£i thÃ­ch nhÆ° Senior cho Intern
================================================================================

Má»¤C Lá»¤C:
I.   JWT & SPRING SECURITY
II.  WEBSOCKET & STOMP
III. KAFKA MESSAGING
IV.  REDIS CACHE
V.   CLOUDINARY & FILE UPLOAD
VI.  CLEAN ARCHITECTURE

================================================================================
I. JWT & SPRING SECURITY - XÃC THá»°C NGÆ¯á»œI DÃ™NG
================================================================================

1. Váº¤N Äá»€ Cáº¦N GIáº¢I QUYáº¾T
---------------------------
TÃ¬nh huá»‘ng: User Ä‘Äƒng nháº­p vÃ o Facebook
- LÃ m sao server biáº¿t request tiáº¿p theo lÃ  cá»§a user nÃ o?
- LÃ m sao khÃ´ng pháº£i Ä‘Äƒng nháº­p láº¡i má»—i láº§n refresh trang?
- LÃ m sao báº£o máº­t thÃ´ng tin user?

2. GIáº¢I PHÃP: JWT (JSON Web Token)
----------------------------------
JWT lÃ  1 chuá»—i string mÃ£ hÃ³a chá»©a thÃ´ng tin user.

VÃ­ dá»¥ JWT:
eyJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiIxMjMiLCJlbWFpbCI6InR1QGdtYWlsLmNvbSJ9.abc123xyz

Cáº¥u trÃºc JWT gá»“m 3 pháº§n (ngÄƒn cÃ¡ch bá»Ÿi dáº¥u .):
- Header: Thuáº­t toÃ¡n mÃ£ hÃ³a (HS256)
- Payload: Dá»¯ liá»‡u user (userId, email, roles...)
- Signature: Chá»¯ kÃ½ báº£o máº­t (dÃ¹ng secret key)

3. FLOW ÄÄ‚NG NHáº¬P Vá»šI JWT
-------------------------

BÆ°á»›c 1: User gá»­i username + password
POST /api/v1/auth/login
{
  "username": "tu@gmail.com",
  "password": "123456"
}

BÆ°á»›c 2: Server kiá»ƒm tra password
- Láº¥y user tá»« database
- So sÃ¡nh password (dÃ¹ng BCrypt)
- Náº¿u Ä‘Ãºng â†’ Táº¡o JWT token

BÆ°á»›c 3: Server tráº£ vá» JWT
{
  "accessToken": "eyJhbGci...",
  "refreshToken": "xyz123...",
  "expiresIn": 900000  // 15 phÃºt
}

BÆ°á»›c 4: Client lÆ°u token (localStorage hoáº·c cookie)

BÆ°á»›c 5: Má»—i request sau, client gá»­i token trong header
GET /api/v1/posts
Headers:
  Authorization: Bearer eyJhbGci...

BÆ°á»›c 6: Server verify token
- Giáº£i mÃ£ JWT
- Kiá»ƒm tra signature (cÃ³ bá»‹ giáº£ máº¡o khÃ´ng?)
- Kiá»ƒm tra expiration (háº¿t háº¡n chÆ°a?)
- Láº¥y userId tá»« token â†’ Biáº¿t user nÃ o Ä‘ang request

4. Táº I SAO Cáº¦N 2 LOáº I TOKEN?
-----------------------------
Access Token (15 phÃºt):
- DÃ¹ng cho má»i API request
- Thá»i gian ngáº¯n â†’ An toÃ n hÆ¡n náº¿u bá»‹ Ä‘Ã¡nh cáº¯p
- Háº¿t háº¡n nhanh â†’ Pháº£i refresh

Refresh Token (7 ngÃ y):
- Chá»‰ dÃ¹ng Ä‘á»ƒ láº¥y access token má»›i
- Thá»i gian dÃ i â†’ User khÃ´ng pháº£i Ä‘Äƒng nháº­p láº¡i
- LÆ°u trong database â†’ CÃ³ thá»ƒ revoke (thu há»“i)

Flow Refresh Token:
1. Access token háº¿t háº¡n â†’ API tráº£ 401 Unauthorized
2. Client gá»­i refresh token â†’ POST /api/v1/auth/refresh-token
3. Server kiá»ƒm tra refresh token trong DB
4. Náº¿u há»£p lá»‡ â†’ Táº¡o access token má»›i
5. Client dÃ¹ng access token má»›i tiáº¿p tá»¥c

5. SPRING SECURITY - Báº¢O Vá»† API
--------------------------------
Spring Security lÃ  framework báº£o máº­t, hoáº¡t Ä‘á»™ng nhÆ° "cá»•ng kiá»ƒm soÃ¡t".


Flow Request qua Spring Security:

Request â†’ JwtAuthenticationFilter â†’ SecurityContext â†’ Controller
   â†“              â†“                        â†“              â†“
 /api/v1/posts  Verify JWT          LÆ°u user info    Xá»­ lÃ½ logic

JwtAuthenticationFilter lÃ m gÃ¬?
1. Láº¥y token tá»« header: Authorization: Bearer xxx
2. Verify token (JwtTokenProvider)
3. Láº¥y userId tá»« token
4. Load user tá»« DB (CustomUserDetailsService)
5. LÆ°u vÃ o SecurityContext (Spring biáº¿t user nÃ o Ä‘ang login)
6. Cho request Ä‘i tiáº¿p

SecurityConfig.java - Cáº¥u hÃ¬nh quyá»n truy cáº­p:
@Configuration
public class SecurityConfig {
    
    // API nÃ o khÃ´ng cáº§n login?
    public static final String[] PUBLIC_URLS = {
        "/api/v1/auth/login",
        "/api/v1/auth/register",
        "/swagger-ui/**"
    };
    
    // API nÃ o cáº§n login?
    .requestMatchers("/api/v1/posts/**").authenticated()
    
    // API nÃ o cáº§n role ADMIN?
    .requestMatchers("/api/v1/admin/**").hasRole("ADMIN")
}

6. MÃƒ HÃ“A PASSWORD - BCRYPT
----------------------------
KHÃ”NG BAO GIá»œ lÆ°u password dáº¡ng plain text!

Sai: password = "123456" â†’ LÆ°u vÃ o DB
ÄÃºng: password = "123456" â†’ BCrypt â†’ "$2a$12$abc..." â†’ LÆ°u vÃ o DB

BCrypt lÃ  gÃ¬?
- Thuáº­t toÃ¡n mÃ£ hÃ³a 1 chiá»u (khÃ´ng giáº£i mÃ£ Ä‘Æ°á»£c)
- Má»—i láº§n mÃ£ hÃ³a cho káº¿t quáº£ khÃ¡c (cÃ³ salt ngáº«u nhiÃªn)
- Cháº­m (cost factor 12) â†’ KhÃ³ brute force

VÃ­ dá»¥:
BCrypt.hashpw("123456", BCrypt.gensalt(12))
â†’ "$2a$12$N0IA..." (60 kÃ½ tá»±)

Kiá»ƒm tra password:
BCrypt.checkpw("123456", "$2a$12$N0IA...") â†’ true/false


================================================================================
II. WEBSOCKET & STOMP - REAL-TIME COMMUNICATION
================================================================================

1. Váº¤N Äá»€ Cáº¦N GIáº¢I QUYáº¾T
-------------------------
TÃ¬nh huá»‘ng: Chat real-time nhÆ° Messenger
- HTTP thÃ´ng thÆ°á»ng: Client há»i â†’ Server tráº£ lá»i (1 chiá»u)
- Chat cáº§n: Server chá»§ Ä‘á»™ng gá»­i tin nháº¯n cho client (2 chiá»u)

Giáº£i phÃ¡p cÅ© (tá»‡):
- Polling: Client há»i server má»—i 1 giÃ¢y "CÃ³ tin nháº¯n má»›i khÃ´ng?"
  â†’ LÃ£ng phÃ­ bandwidth, cháº­m

Giáº£i phÃ¡p má»›i (tá»‘t):
- WebSocket: Káº¿t ná»‘i 2 chiá»u, server push tin nháº¯n ngay láº­p tá»©c


2. WEBSOCKET LÃ€ GÃŒ?
--------------------
WebSocket = Káº¿t ná»‘i TCP liÃªn tá»¥c giá»¯a client vÃ  server.

HTTP thÃ´ng thÆ°á»ng:
Client: "Cho tÃ´i danh sÃ¡ch posts"
Server: "ÄÃ¢y, 10 posts"
[ÄÃ³ng káº¿t ná»‘i]

WebSocket:
Client: "Káº¿t ná»‘i vá»›i tÃ´i" (handshake)
Server: "OK, káº¿t ná»‘i má»Ÿ"
[Káº¿t ná»‘i luÃ´n má»Ÿ]
Server: "CÃ³ tin nháº¯n má»›i!" (push)
Client: "Gá»­i tin nháº¯n: Hello" (send)
Server: "ÄÃ£ nháº­n" (push)

3. STOMP PROTOCOL
-----------------
STOMP = Simple Text Oriented Messaging Protocol
LÃ  protocol cháº¡y trÃªn WebSocket, giá»‘ng nhÆ° "ngÃ´n ngá»¯" Ä‘á»ƒ giao tiáº¿p.

Táº¡i sao cáº§n STOMP?
- WebSocket thuáº§n chá»‰ gá»­i/nháº­n string
- STOMP thÃªm cáº¥u trÃºc: destination, headers, body
- Giá»‘ng nhÆ° HTTP cÃ³ GET/POST, STOMP cÃ³ SEND/SUBSCRIBE

STOMP Commands:
- CONNECT: Káº¿t ná»‘i tá»›i server
- SUBSCRIBE: ÄÄƒng kÃ½ nháº­n tin tá»« 1 topic
- SEND: Gá»­i tin nháº¯n tá»›i 1 destination
- DISCONNECT: Ngáº¯t káº¿t ná»‘i

4. FLOW CHAT REAL-TIME
----------------------
BÆ°á»›c 1: Client káº¿t ná»‘i WebSocket
const socket = new SockJS('http://localhost:8080/ws');
const stompClient = Stomp.over(socket);

stompClient.connect({
  Authorization: 'Bearer eyJhbGci...'  // JWT token
}, function(frame) {
  console.log('Connected');
});

BÆ°á»›c 2: Client subscribe vÃ o room chat
stompClient.subscribe('/topic/room/123', function(message) {
  // Nháº­n tin nháº¯n má»›i
  const msg = JSON.parse(message.body);
  console.log('New message:', msg.content);
});

BÆ°á»›c 3: User A gá»­i tin nháº¯n
stompClient.send('/app/chat/send', {}, JSON.stringify({
  roomId: '123',
  content: 'Hello everyone!'
}));

BÆ°á»›c 4: Server nháº­n tin nháº¯n
@MessageMapping("/chat/send")  // Nháº­n tá»« /app/chat/send
@SendTo("/topic/room/{roomId}")  // Gá»­i tá»›i /topic/room/123
public MessageResponse sendMessage(SendMessageRequest request) {
    // LÆ°u tin nháº¯n vÃ o DB
    Message message = messageService.save(request);
    
    // Tráº£ vá» cho táº¥t cáº£ clients Ä‘ang subscribe
    return new MessageResponse(message);
}

BÆ°á»›c 5: Táº¥t cáº£ clients trong room nháº­n tin nháº¯n
- User A, B, C Ä‘á»u subscribe /topic/room/123
- Server gá»­i tin nháº¯n tá»›i topic nÃ y
- A, B, C Ä‘á»u nháº­n Ä‘Æ°á»£c tin nháº¯n real-time


5. DESTINATION TYPES
--------------------
/topic/xxx - Broadcast (1 gá»­i, nhiá»u ngÆ°á»i nháº­n)
VÃ­ dá»¥: /topic/room/123
- User A gá»­i tin nháº¯n
- Táº¥t cáº£ user trong room Ä‘á»u nháº­n

/queue/xxx - Point-to-point (1 gá»­i, 1 ngÆ°á»i nháº­n)
VÃ­ dá»¥: /queue/user/456/private
- Gá»­i tin nháº¯n riÃªng cho user 456
- Chá»‰ user 456 nháº­n Ä‘Æ°á»£c

/user/queue/xxx - User-specific queue
VÃ­ dá»¥: /user/queue/notifications
- Má»—i user cÃ³ queue riÃªng
- Chá»‰ user Ä‘Ã³ nháº­n Ä‘Æ°á»£c

6. XÃC THá»°C WEBSOCKET Vá»šI JWT
------------------------------
Váº¥n Ä‘á»: WebSocket khÃ´ng cÃ³ header nhÆ° HTTP
Giáº£i phÃ¡p: Gá»­i JWT trong handshake

Client:
stompClient.connect({
  Authorization: 'Bearer eyJhbGci...'
}, callback);

Server (WebSocketConfig):
@Override
public void configureClientInboundChannel(ChannelRegistration registration) {
    registration.interceptors(new ChannelInterceptor() {
        @Override
        public Message<?> preSend(Message<?> message, MessageChannel channel) {
            // Láº¥y JWT tá»« header
            String token = getTokenFromMessage(message);
            
            // Verify JWT
            if (jwtTokenProvider.validateToken(token)) {
                String userId = jwtTokenProvider.getUserIdFromToken(token);
                // LÆ°u user vÃ o SecurityContext
            }
            
            return message;
        }
    });
}


================================================================================
III. KAFKA MESSAGING - ASYNC PROCESSING
================================================================================

1. Váº¤N Äá»€ Cáº¦N GIáº¢I QUYáº¾T
-------------------------
TÃ¬nh huá»‘ng: User Ä‘Äƒng bÃ i viáº¿t
- LÆ°u post vÃ o DB (nhanh - 50ms)
- Gá»­i notification cho 1000 followers (cháº­m - 5s)
- Gá»­i email cho admin (cháº­m - 2s)
- Xá»­ lÃ½ áº£nh/video (ráº¥t cháº­m - 30s)

Náº¿u lÃ m Ä‘á»“ng bá»™ (synchronous):
User Ä‘Äƒng bÃ i â†’ Äá»£i 37 giÃ¢y â†’ Má»›i tháº¥y bÃ i Ä‘Äƒng
â†’ Tráº£i nghiá»‡m tá»‡!

Giáº£i phÃ¡p: Xá»­ lÃ½ báº¥t Ä‘á»“ng bá»™ (asynchronous) vá»›i Kafka

2. KAFKA LÃ€ GÃŒ?
---------------
Kafka = Message Queue (HÃ ng Ä‘á»£i tin nháº¯n)
Giá»‘ng nhÆ° bÆ°u Ä‘iá»‡n: Gá»­i thÆ° â†’ BÆ°u Ä‘iá»‡n giá»¯ â†’ NgÆ°á»i nháº­n láº¥y sau


ThÃ nh pháº§n Kafka:
- Producer: NgÆ°á»i gá»­i tin (PostService)
- Topic: Chá»§ Ä‘á» tin nháº¯n (post-created, notification-sent)
- Consumer: NgÆ°á»i nháº­n tin (NotificationService, EmailService)
- Broker: Server Kafka (lÆ°u trá»¯ tin nháº¯n)

3. FLOW ÄÄ‚NG BÃ€I Vá»šI KAFKA
--------------------------
BÆ°á»›c 1: User Ä‘Äƒng bÃ i
POST /api/v1/posts
{
  "content": "Hello world!",
  "images": ["img1.jpg"]
}

BÆ°á»›c 2: PostService xá»­ lÃ½ nhanh
@Service
public class PostService {
    
    @Autowired
    private KafkaTemplate<String, PostCreatedEvent> kafkaTemplate;
    
    public PostResponse createPost(CreatePostRequest request) {
        // 1. LÆ°u post vÃ o DB (nhanh - 50ms)
        Post post = postRepository.save(new Post(request));
        
        // 2. Gá»­i event vÃ o Kafka (ráº¥t nhanh - 5ms)
        PostCreatedEvent event = new PostCreatedEvent(
            post.getId(),
            post.getUserId(),
            post.getContent()
        );
        kafkaTemplate.send("post-created", event);
        
        // 3. Tráº£ vá» ngay cho user (tá»•ng 55ms)
        return new PostResponse(post);
    }
}

BÆ°á»›c 3: Kafka lÆ°u event vÃ o topic "post-created"

BÆ°á»›c 4: CÃ¡c Consumer xá»­ lÃ½ cháº­m (background)
// Consumer 1: Gá»­i notification
@KafkaListener(topics = "post-created")
public void handlePostCreated(PostCreatedEvent event) {
    // Láº¥y 1000 followers
    List<User> followers = userService.getFollowers(event.getUserId());
    
    // Gá»­i notification cho tá»«ng ngÆ°á»i (5s)
    followers.forEach(follower -> {
        notificationService.send(follower.getId(), "New post from ...");
    });
}

// Consumer 2: Gá»­i email
@KafkaListener(topics = "post-created")
public void sendEmailToAdmin(PostCreatedEvent event) {
    emailService.send("admin@example.com", "New post created");
}

// Consumer 3: Xá»­ lÃ½ áº£nh
@KafkaListener(topics = "post-created")
public void processImages(PostCreatedEvent event) {
    // Resize, compress, upload to Cloudinary (30s)
}

Káº¿t quáº£:
- User tháº¥y bÃ i Ä‘Äƒng ngay láº­p tá»©c (55ms)
- Notification, email, xá»­ lÃ½ áº£nh cháº¡y background
- Náº¿u cÃ³ lá»—i â†’ Kafka retry tá»± Ä‘á»™ng


4. KAFKA CONCEPTS
-----------------
Topic: Chá»§ Ä‘á» tin nháº¯n
- Giá»‘ng nhÆ° folder: post-created, user-registered, email-sent
- Má»—i topic cÃ³ nhiá»u partitions (Ä‘á»ƒ scale)

Partition: PhÃ¢n vÃ¹ng cá»§a topic
- Topic "post-created" cÃ³ 3 partitions: 0, 1, 2
- Tin nháº¯n Ä‘Æ°á»£c phÃ¢n bá»• Ä‘á»u vÃ o cÃ¡c partitions
- Má»—i partition xá»­ lÃ½ Ä‘á»™c láº­p â†’ Nhanh hÆ¡n

Consumer Group: NhÃ³m consumers
- Nhiá»u consumers cÃ¹ng xá»­ lÃ½ 1 topic
- Má»—i partition chá»‰ Ä‘Æ°á»£c 1 consumer trong group xá»­ lÃ½
- Náº¿u 1 consumer cháº¿t â†’ Consumer khÃ¡c thay tháº¿

Offset: Vá»‹ trÃ­ Ä‘á»c tin nháº¯n
- Kafka lÆ°u offset cá»§a má»—i consumer
- Consumer Ä‘á»c tá»« offset cuá»‘i cÃ¹ng
- Náº¿u consumer restart â†’ Tiáº¿p tá»¥c tá»« offset cÅ© (khÃ´ng máº¥t tin)

5. KHI NÃ€O DÃ™NG KAFKA?
----------------------
âœ… DÃ¹ng Kafka khi:
- Xá»­ lÃ½ cháº­m (gá»­i email, xá»­ lÃ½ áº£nh/video)
- KhÃ´ng cáº§n káº¿t quáº£ ngay (notification, logging)
- Cáº§n retry náº¿u lá»—i
- Cáº§n scale (nhiá»u consumers xá»­ lÃ½ song song)

âŒ KHÃ”NG dÃ¹ng Kafka khi:
- Cáº§n káº¿t quáº£ ngay láº­p tá»©c (login, get profile)
- Logic Ä‘Æ¡n giáº£n, nhanh (< 100ms)
- KhÃ´ng cáº§n retry


================================================================================
IV. REDIS CACHE - TÄ‚NG Tá»C á»¨NG Dá»¤NG
================================================================================

1. Váº¤N Äá»€ Cáº¦N GIáº¢I QUYáº¾T
-------------------------
TÃ¬nh huá»‘ng: Xem profile user
- Query DB: SELECT * FROM users WHERE id = 123 (50ms)
- User xem profile 1000 láº§n/ngÃ y
- Tá»•ng: 1000 * 50ms = 50 giÃ¢y query DB má»—i ngÃ y
- DB bá»‹ quÃ¡ táº£i!

Giáº£i phÃ¡p: Cache vá»›i Redis

2. REDIS LÃ€ GÃŒ?
---------------
Redis = In-memory database (Database trong RAM)
- LÆ°u dá»¯ liá»‡u trong RAM â†’ Cá»±c nhanh (< 1ms)
- Key-Value store: key = "user:123", value = {user data}
- DÃ¹ng Ä‘á»ƒ cache dá»¯ liá»‡u hay truy cáº­p

3. FLOW CACHE
-------------
Láº§n 1: Cache miss (khÃ´ng cÃ³ trong cache)
1. Client: GET /api/v1/users/123
2. Server kiá»ƒm tra Redis: GET user:123 â†’ null
3. Server query DB: SELECT * FROM users WHERE id = 123 (50ms)
4. Server lÆ°u vÃ o Redis: SET user:123 {user data} EX 3600 (1 giá»)
5. Server tráº£ vá» client

Láº§n 2: Cache hit (cÃ³ trong cache)
1. Client: GET /api/v1/users/123
2. Server kiá»ƒm tra Redis: GET user:123 â†’ {user data} (< 1ms)
3. Server tráº£ vá» ngay (khÃ´ng query DB)


4. CACHE STRATEGIES
-------------------
Cache-Aside (Lazy Loading):
- Äá»c: Kiá»ƒm tra cache â†’ Náº¿u khÃ´ng cÃ³ â†’ Query DB â†’ LÆ°u cache
- Ghi: Cáº­p nháº­t DB â†’ XÃ³a cache
- DÃ¹ng nhiá»u nháº¥t

Write-Through:
- Ghi: Cáº­p nháº­t DB â†’ Cáº­p nháº­t cache cÃ¹ng lÃºc
- Äá»c: LuÃ´n cÃ³ trong cache
- DÃ¹ng cho dá»¯ liá»‡u quan trá»ng

Write-Behind:
- Ghi: Cáº­p nháº­t cache â†’ Sau Ä‘Ã³ má»›i cáº­p nháº­t DB (async)
- Nhanh nhÆ°ng rá»§i ro máº¥t dá»¯ liá»‡u

5. CODE EXAMPLE
---------------
@Service
public class UserService {
    
    @Autowired
    private RedisTemplate<String, User> redisTemplate;
    
    @Autowired
    private UserRepository userRepository;
    
    public User getUserById(String userId) {
        String cacheKey = "user:" + userId;
        
        // 1. Kiá»ƒm tra cache
        User user = redisTemplate.opsForValue().get(cacheKey);
        
        if (user != null) {
            // Cache hit
            return user;
        }
        
        // 2. Cache miss â†’ Query DB
        user = userRepository.findById(userId)
            .orElseThrow(() -> new NotFoundException("User not found"));
        
        // 3. LÆ°u vÃ o cache (TTL 1 giá»)
        redisTemplate.opsForValue().set(cacheKey, user, 1, TimeUnit.HOURS);
        
        return user;
    }
    
    public User updateUser(String userId, UpdateUserRequest request) {
        // 1. Cáº­p nháº­t DB
        User user = userRepository.findById(userId).orElseThrow();
        user.setName(request.getName());
        userRepository.save(user);
        
        // 2. XÃ³a cache (Ä‘á»ƒ láº§n Ä‘á»c sau query DB láº¡i)
        String cacheKey = "user:" + userId;
        redisTemplate.delete(cacheKey);
        
        return user;
    }
}

6. CACHE INVALIDATION (XÃ³a cache)
----------------------------------
Váº¥n Ä‘á»: Dá»¯ liá»‡u trong cache cÅ©, DB Ä‘Ã£ thay Ä‘á»•i

Giáº£i phÃ¡p 1: TTL (Time To Live)
- Set thá»i gian háº¿t háº¡n: 1 giá», 1 ngÃ y
- Háº¿t háº¡n â†’ Redis tá»± Ä‘á»™ng xÃ³a
- ÄÆ¡n giáº£n nhÆ°ng cÃ³ thá»ƒ tráº£ dá»¯ liá»‡u cÅ©

Giáº£i phÃ¡p 2: Event-driven invalidation
- Khi update user â†’ Gá»­i event qua Kafka
- Consumer nháº­n event â†’ XÃ³a cache
- Phá»©c táº¡p nhÆ°ng chÃ­nh xÃ¡c


7. KHI NÃ€O DÃ™NG CACHE?
----------------------
âœ… DÃ¹ng cache khi:
- Dá»¯ liá»‡u Ä‘á»c nhiá»u, ghi Ã­t (user profile, posts)
- Dá»¯ liá»‡u Ã­t thay Ä‘á»•i (settings, categories)
- Query DB cháº­m (join nhiá»u báº£ng)
- Cáº§n giáº£m táº£i DB

âŒ KHÃ”NG cache khi:
- Dá»¯ liá»‡u thay Ä‘á»•i liÃªn tá»¥c (stock price, live score)
- Dá»¯ liá»‡u nháº¡y cáº£m (password, payment info)
- Dá»¯ liá»‡u lá»›n (video, file)


================================================================================
V. CLOUDINARY & FILE UPLOAD - LÆ¯U TRá»® MEDIA
================================================================================

1. Váº¤N Äá»€ Cáº¦N GIáº¢I QUYáº¾T
-------------------------
TÃ¬nh huá»‘ng: User upload áº£nh avatar
- LÆ°u á»Ÿ Ä‘Ã¢u? (Server, DB, Cloud?)
- LÃ m sao resize áº£nh? (1MB â†’ 100KB)
- LÃ m sao serve áº£nh nhanh? (CDN)

Giáº£i phÃ¡p: Cloudinary (Cloud storage + CDN + Image processing)

2. CLOUDINARY LÃ€ GÃŒ?
--------------------
Cloudinary = Cloud storage cho áº£nh/video
- Upload áº£nh â†’ Cloudinary lÆ°u trá»¯
- Tá»± Ä‘á»™ng resize, compress, optimize
- CDN toÃ n cáº§u â†’ Load áº£nh nhanh
- Free tier: 25GB storage, 25GB bandwidth/thÃ¡ng

3. FLOW UPLOAD áº¢NH
------------------
BÆ°á»›c 1: Client chá»n áº£nh
<input type="file" accept="image/*" />

BÆ°á»›c 2: Client gá»­i áº£nh lÃªn server
POST /api/v1/media/upload
Content-Type: multipart/form-data
Body: file = avatar.jpg (5MB)

BÆ°á»›c 3: Server upload lÃªn Cloudinary
@RestController
public class MediaController {
    
    @Autowired
    private CloudinaryStorageService cloudinaryService;
    
    @PostMapping("/upload")
    public MediaResponse uploadImage(@RequestParam("file") MultipartFile file) {
        // 1. Validate file
        if (file.getSize() > 10 * 1024 * 1024) {  // 10MB
            throw new ValidationException("File too large");
        }
        
        if (!file.getContentType().startsWith("image/")) {
            throw new ValidationException("Only images allowed");
        }
        
        // 2. Upload to Cloudinary
        String imageUrl = cloudinaryService.upload(file);
        
        // 3. LÆ°u metadata vÃ o DB
        Media media = new Media();
        media.setUrl(imageUrl);
        media.setType(MediaType.IMAGE);
        mediaRepository.save(media);
        
        return new MediaResponse(media);
    }
}


BÆ°á»›c 4: CloudinaryStorageService xá»­ lÃ½
@Service
public class CloudinaryStorageService {
    
    @Autowired
    private Cloudinary cloudinary;
    
    public String upload(MultipartFile file) {
        try {
            // Upload vá»›i options
            Map<String, Object> options = new HashMap<>();
            options.put("folder", "social-media/avatars");
            options.put("resource_type", "auto");
            options.put("transformation", new Transformation()
                .width(500).height(500).crop("fill")  // Resize 500x500
                .quality("auto")  // Auto optimize
                .fetchFormat("auto")  // Auto format (WebP náº¿u browser há»— trá»£)
            );
            
            // Upload
            Map uploadResult = cloudinary.uploader().upload(
                file.getBytes(), 
                options
            );
            
            // Láº¥y URL
            String imageUrl = (String) uploadResult.get("secure_url");
            return imageUrl;
            
        } catch (IOException e) {
            throw new RuntimeException("Upload failed", e);
        }
    }
}

BÆ°á»›c 5: Cloudinary tráº£ vá» URL
https://res.cloudinary.com/demo/image/upload/v1234/social-media/avatars/abc123.jpg

BÆ°á»›c 6: Client hiá»ƒn thá»‹ áº£nh
<img src="https://res.cloudinary.com/.../abc123.jpg" />

4. CLOUDINARY TRANSFORMATIONS
------------------------------
Resize on-the-fly (khÃ´ng cáº§n upload láº¡i):

Original URL:
https://res.cloudinary.com/demo/image/upload/avatar.jpg

Resize 200x200:
https://res.cloudinary.com/demo/image/upload/w_200,h_200,c_fill/avatar.jpg

Thumbnail 100x100:
https://res.cloudinary.com/demo/image/upload/w_100,h_100,c_thumb/avatar.jpg

Blur:
https://res.cloudinary.com/demo/image/upload/e_blur:300/avatar.jpg

Grayscale:
https://res.cloudinary.com/demo/image/upload/e_grayscale/avatar.jpg

5. VIDEO UPLOAD
---------------
TÆ°Æ¡ng tá»± áº£nh, nhÆ°ng:
- Max size: 100MB
- Auto transcode (MP4, WebM)
- Generate thumbnail tá»± Ä‘á»™ng
- Adaptive streaming (HLS, DASH)


================================================================================
VI. CLEAN ARCHITECTURE - Tá»” CHá»¨C CODE
================================================================================

1. Váº¤N Äá»€ Cáº¦N GIáº¢I QUYáº¾T
-------------------------
Dá»± Ã¡n lá»›n, nhiá»u ngÆ°á»i lÃ m:
- Code lá»™n xá»™n, khÃ´ng biáº¿t file nÃ o á»Ÿ Ä‘Ã¢u
- Thay Ä‘á»•i 1 chá»— â†’ áº¢nh hÆ°á»Ÿng nhiá»u chá»— khÃ¡c
- KhÃ³ test, khÃ³ maintain

Giáº£i phÃ¡p: Clean Architecture (Kiáº¿n trÃºc sáº¡ch)


2. 4 LAYERS Cá»¦A CLEAN ARCHITECTURE
----------------------------------

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   PRESENTATION LAYER (Giao diá»‡n)   â”‚  â† Controllers, DTOs
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   APPLICATION LAYER (Logic nghiá»‡p vá»¥)â”‚  â† Services, Use Cases
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   DOMAIN LAYER (Trung tÃ¢m)         â”‚  â† Entities, Repositories
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   INFRASTRUCTURE LAYER (Ká»¹ thuáº­t)  â”‚  â† DB, Kafka, Redis, Cloudinary
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

NguyÃªn táº¯c: Layer trong KHÃ”NG phá»¥ thuá»™c layer ngoÃ i
- Domain khÃ´ng biáº¿t gÃ¬ vá» Controller, DB, Kafka
- Application chá»‰ biáº¿t Domain
- Infrastructure implement interface cá»§a Domain

3. DOMAIN LAYER (Trung tÃ¢m)
---------------------------
Chá»©a: Entities, Repository Interfaces, Business Rules

Entity = Äá»‘i tÆ°á»£ng nghiá»‡p vá»¥ (User, Post, Comment)
@Entity
@Table(name = "users")
public class User {
    @Id
    private UUID id;
    
    @Column(unique = true, nullable = false)
    private String email;
    
    private String passwordHash;
    
    // Business logic
    public boolean isActive() {
        return this.isActive && !this.isBlocked;
    }
    
    public void changePassword(String newPassword) {
        // Validate password strength
        if (newPassword.length() < 8) {
            throw new ValidationException("Password too short");
        }
        this.passwordHash = BCrypt.hashpw(newPassword, BCrypt.gensalt());
    }
}

Repository Interface (chá»‰ Ä‘á»‹nh nghÄ©a, khÃ´ng implement)
public interface UserRepository extends JpaRepository<User, UUID> {
    Optional<User> findByEmail(String email);
    List<User> findByIsActiveTrue();
}

4. APPLICATION LAYER (Logic nghiá»‡p vá»¥)
---------------------------------------
Chá»©a: Services, Use Cases, Mappers

Service = Xá»­ lÃ½ logic nghiá»‡p vá»¥
@Service
public class PostService {
    
    @Autowired
    private PostRepository postRepository;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private KafkaTemplate kafkaTemplate;
    
    @Transactional
    public PostResponse createPost(CreatePostRequest request, String userId) {
        // 1. Validate
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new NotFoundException("User not found"));
        
        if (!user.isActive()) {
            throw new ForbiddenException("User is not active");
        }
        
        // 2. Business logic
        Post post = new Post();
        post.setUserId(userId);
        post.setContent(request.getContent());
        post.setPrivacy(request.getPrivacy());
        
        // 3. Save to DB
        post = postRepository.save(post);
        
        // 4. Send event (async)
        kafkaTemplate.send("post-created", new PostCreatedEvent(post));
        
        // 5. Return DTO
        return PostMapper.toResponse(post);
    }
}


5. PRESENTATION LAYER (Giao diá»‡n)
----------------------------------
Chá»©a: Controllers, DTOs, Exception Handlers

Controller = Nháº­n request, gá»i Service, tráº£ response
@RestController
@RequestMapping("/api/v1/posts")
public class PostController {
    
    @Autowired
    private PostService postService;
    
    @PostMapping
    public ResponseEntity<ApiResponse<PostResponse>> createPost(
        @Valid @RequestBody CreatePostRequest request,
        @AuthenticationPrincipal UserDetails userDetails
    ) {
        String userId = userDetails.getUsername();
        PostResponse post = postService.createPost(request, userId);
        
        return ResponseEntity.ok(
            ApiResponse.success(post, "Post created successfully")
        );
    }
    
    @GetMapping("/{postId}")
    public ResponseEntity<ApiResponse<PostResponse>> getPost(
        @PathVariable String postId
    ) {
        PostResponse post = postService.getPostById(postId);
        return ResponseEntity.ok(ApiResponse.success(post));
    }
}

DTO = Data Transfer Object (Chá»‰ chá»©a data, khÃ´ng cÃ³ logic)
// Request DTO
public class CreatePostRequest {
    @NotBlank(message = "Content is required")
    @Size(max = 5000, message = "Content too long")
    private String content;
    
    @NotNull
    private PostPrivacy privacy;
    
    private List<String> imageUrls;
}

// Response DTO
public class PostResponse {
    private String id;
    private String content;
    private PostPrivacy privacy;
    private UserResponse author;
    private int likesCount;
    private int commentsCount;
    private LocalDateTime createdAt;
}

6. INFRASTRUCTURE LAYER (Ká»¹ thuáº­t)
-----------------------------------
Chá»©a: DB implementation, External services, Kafka, Redis

Kafka Producer:
@Service
public class NotificationProducer {
    
    @Autowired
    private KafkaTemplate<String, NotificationEvent> kafkaTemplate;
    
    public void sendNotification(NotificationEvent event) {
        kafkaTemplate.send("notifications", event);
    }
}

Redis Cache:
@Service
public class RedisCacheService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    public void set(String key, Object value, long ttl) {
        redisTemplate.opsForValue().set(key, value, ttl, TimeUnit.SECONDS);
    }
    
    public Object get(String key) {
        return redisTemplate.opsForValue().get(key);
    }
}


7. Lá»¢I ÃCH Cá»¦A CLEAN ARCHITECTURE
---------------------------------
âœ… Dá»… tÃ¬m code: Biáº¿t ngay file á»Ÿ layer nÃ o
âœ… Dá»… test: Mock layer ngoÃ i, test logic riÃªng
âœ… Dá»… thay Ä‘á»•i: Äá»•i DB tá»« PostgreSQL â†’ MongoDB chá»‰ sá»­a Infrastructure
âœ… Dá»… maintain: Má»—i layer cÃ³ trÃ¡ch nhiá»‡m rÃµ rÃ ng
âœ… Dá»… lÃ m viá»‡c nhÃ³m: Chia task theo layer

8. QUY Táº®C Äáº¶T TÃŠN
------------------
Entity: User, Post, Comment (danh tá»« sá»‘ Ã­t)
Repository: UserRepository, PostRepository (Entity + Repository)
Service: UserService, PostService (Entity + Service)
Controller: UserController, PostController (Entity + Controller)
DTO Request: CreatePostRequest, UpdateUserRequest (Action + Entity + Request)
DTO Response: PostResponse, UserResponse (Entity + Response)


================================================================================
VII. Tá»”NG Káº¾T - FLOW HOÃ€N CHá»ˆNH
================================================================================

VÃ­ dá»¥: User Ä‘Äƒng bÃ i viáº¿t cÃ³ áº£nh

1. CLIENT Gá»¬I REQUEST
----------------------
POST /api/v1/posts
Headers:
  Authorization: Bearer eyJhbGci...
Body:
{
  "content": "Beautiful sunset!",
  "imageUrls": ["https://cloudinary.com/.../sunset.jpg"],
  "privacy": "PUBLIC"
}

2. SPRING SECURITY VERIFY JWT
------------------------------
JwtAuthenticationFilter:
- Láº¥y token tá»« header
- Verify signature
- Láº¥y userId tá»« token
- Load user tá»« DB
- LÆ°u vÃ o SecurityContext

3. CONTROLLER NHáº¬N REQUEST
---------------------------
PostController:
- Validate request (@Valid)
- Láº¥y userId tá»« SecurityContext
- Gá»i PostService.createPost()

4. SERVICE Xá»¬ LÃ LOGIC
-----------------------
PostService:
- Validate user cÃ³ active khÃ´ng
- Táº¡o Post entity
- LÆ°u vÃ o DB (PostgreSQL)
- Gá»­i event vÃ o Kafka topic "post-created"
- Return PostResponse

5. KAFKA CONSUMER Xá»¬ LÃ ASYNC
------------------------------
NotificationConsumer:
- Nháº­n event tá»« topic "post-created"
- Láº¥y danh sÃ¡ch followers
- Gá»­i notification cho tá»«ng follower
- LÆ°u notification vÃ o DB
- Push qua WebSocket cho followers Ä‘ang online

6. WEBSOCKET PUSH NOTIFICATION
-------------------------------
NotificationWebSocketHandler:
- Láº¥y danh sÃ¡ch followers Ä‘ang online
- Push notification qua WebSocket
- Followers nháº­n notification real-time

7. REDIS CACHE
--------------
- Cache post má»›i vÃ o Redis (key: "post:123")
- Cache newsfeed cá»§a user (key: "newsfeed:user:456")
- TTL: 5 phÃºt

8. CLIENT NHáº¬N RESPONSE
------------------------
Response (55ms):
{
  "success": true,
  "data": {
    "id": "123",
    "content": "Beautiful sunset!",
    "imageUrls": [...],
    "likesCount": 0,
    "createdAt": "2024-01-20T10:30:00Z"
  }
}

Followers nháº­n notification real-time qua WebSocket (background)


================================================================================
VIII. TIPS & BEST PRACTICES
================================================================================

1. SECURITY
-----------
âœ… LuÃ´n validate input
âœ… DÃ¹ng BCrypt cho password (cost factor 12)
âœ… JWT access token ngáº¯n (15 phÃºt)
âœ… Refresh token dÃ i (7 ngÃ y) vÃ  lÆ°u DB
âœ… HTTPS only trong production
âœ… Rate limiting (100 requests/phÃºt)

2. PERFORMANCE
--------------
âœ… Cache dá»¯ liá»‡u Ä‘á»c nhiá»u (user profile, posts)
âœ… DÃ¹ng Kafka cho xá»­ lÃ½ cháº­m (email, notification)
âœ… Pagination cho list API (20 items/page)
âœ… Index cÃ¡c foreign keys vÃ  search fields
âœ… DÃ¹ng CDN cho static files (Cloudinary)

3. CODE QUALITY
---------------
âœ… Follow Clean Architecture
âœ… Äáº·t tÃªn rÃµ rÃ ng, dá»… hiá»ƒu
âœ… Viáº¿t comment cho logic phá»©c táº¡p
âœ… Handle exception Ä‘Ãºng cÃ¡ch
âœ… Viáº¿t unit test cho Service layer

4. DEBUGGING
------------
âœ… Log má»i thá»© (request, response, error)
âœ… DÃ¹ng correlation ID Ä‘á»ƒ trace request
âœ… Monitor metrics (Actuator + Prometheus)
âœ… Test vá»›i Postman/Swagger trÆ°á»›c khi integrate

5. LEARNING PATH
----------------
1. Há»c JWT & Spring Security trÆ°á»›c (ná»n táº£ng)
2. Sau Ä‘Ã³ há»c WebSocket (real-time)
3. Rá»“i há»c Kafka (async processing)
4. Cuá»‘i cÃ¹ng há»c Redis (optimization)

Má»—i tuáº§n há»c 1 topic, lÃ m demo nhá» Ä‘á»ƒ hiá»ƒu rÃµ.
Äá»«ng há»c háº¿t cÃ¹ng lÃºc â†’ Sáº½ bá»‹ overwhelm!


================================================================================
Káº¾T THÃšC - CHÃšC Báº N Há»ŒC Tá»T!
================================================================================

Nhá»›: Äá»c document, lÃ m demo nhá», há»i khi khÃ´ng hiá»ƒu.
Senior luÃ´n sáºµn sÃ ng giÃºp Ä‘á»¡! ğŸ’ª
